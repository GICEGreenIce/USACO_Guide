# 模拟

## 直接去模拟题目描述的情况

### 前置知识

* [Simulation](https://darrenyao.com/usacobook/cpp.pdf#page=24)

由于不涉及正式算法，问题的目的是评估一个人选择的编程语言和内置数据结构知识的能力。

通常直接模拟题目中的过程就足够了。

### 贝壳游戏(Shell Game)

* 难度：铜

为了消磨时光，奶牛 Bessie 和她的朋友 Elsie 喜欢玩一种她们在农业展览会上看到的游戏。

游戏准备阶段，Bessie 在桌子上放置三个倒置的坚果壳，并在其中一个坚果壳下面藏了一块小的鹅卵石（至少她希望这是一块鹅卵石——她在一块牧场的地上找到的）。

随后 Bessie 会两两调换坚果壳，同时 Elsie 试着去猜鹅卵石的位置。

奶牛们在农业展览会上看到的这个游戏的标准形式是玩家可以看到鹅卵石初始的位置，然后要求玩家猜所有交换完成之后鹅卵石最终的位置。

然而，现在奶牛们想要去进行这样一种玩法，Elsie 不知道鹅卵石的初始位置，同时她可以在每一次交换之后猜一下鹅卵石的位置。

Bessie 知道正确答案，在游戏结束后会给 Elsie 一个分数，等于她猜对的次数。

给定所有的交换和 Elsie 的猜测，但是不给出鹅卵石的初始位置，请求出 Elsie 最高可能获得的分数。

输入格式：

输入的第一行包含一个整数 N，为交换的次数（1≤N≤100）。

以下 N 行每行描述了游戏的一个回合，

包含三个整数 a、b 和 g，表示 Bessie 交换了坚果壳 a 和 b，然后 Elsie 猜的是坚果壳g。

所有这三个数均为 1、2、3 之一，并且 a≠b。

输出格式：

输出 Elsie 可以得到的最高分数。

#### 题解

* 思路

我们可以模拟这个过程。

创建一个数组，该数组跟踪哪个壳位于哪个位置，可以通过交换数组中的元素来模拟 Bessie 的交换。

然后，我们可以计算 Elsie 猜的次数，她能获得的最高分数就是答案。

```cpp
#include <iostream>
int a[100], b[100], g[100], cnt[10], N, maxn;
int main() {
    std::cin >> N;
    for (int i = 0; i < N; i++) {
        std::cin >> a[i] >> b[i] >> g[i]; //读入交换的贝壳以及 Elsie 猜的贝壳
    }
    for (int i = 1; i <= 3; i++) {
        int tmp = i; //tmp 为假设中正确的贝壳
        for (int j = 0; j < N; j++) {
            if (a[j] == tmp) {tmp = b[j];} //交换贝壳
            else if (b[j] == tmp) {tmp = a[j];} 
            if (tmp == g[i]) {cnt[i]++;} //加分
        }
    }
    for (int i = 1; i <= 3; i++) {
        if (cnt[i] > maxn) {maxn = cnt[i];} //比较得出 Elsie 可能得到的最高分
    }
    std::cout << maxn << std::endl; //输出分数
    return 0;
}
```

### 混合牛奶(Mixing Milk)

* 难度：铜

农业，尤其是生产牛奶，是一个竞争激烈的行业。

Farmer John 发现如果他不在牛奶生产工艺上有所创新，他的乳制品生意可能就会受到重创！

幸运的是，Farmer John想出了一个好主意。

他的三头获奖的乳牛，Bessie、Elsie 和 Mildred，各自产奶的口味有些许不同，他打算混合这三种牛奶调制出完美的口味。

为了混合这三种不同的牛奶，他拿来三个桶，其中分别装有三头奶牛所产的奶。

这些桶可能有不同的容积，也可能并没有完全装满。

然后他将桶 1 的牛奶倒入桶 2，然后将桶 2 中的牛奶倒入桶 3，然后将桶 3 中的牛奶倒入桶 1，然后再将桶 1 的牛奶倒入桶 2，如此周期性地操作，共计进行 100 次（所以第 100 次操作会是桶 1 倒入桶 2）。

当 Farmer John 将桶 a 中的牛奶倒入桶 b 时，他会倒出尽可能多的牛奶，直到桶 a 被倒空或是桶 b 被倒满。

请告诉 Farmer John 当他倒了 100 次之后每个桶里将会有多少牛奶。

输入格式：

第一行包含两个空格分隔的整数：第一个桶的容积 c1，以及第一个桶里的牛奶量 m1。

c1 和 m1 均为正，并且不超过 10^9。

第二和第三行类似地包含第二和第三个桶的容积和牛奶量。

输出格式：

输出三行，给出倒了 100 次之后每个桶里的牛奶量。

#### 题解

* 思路

我们可以模拟倒奶的过程。

用数组存储每个桶当前的奶量状况以及可存放的奶量。

```cpp
#include <iostream>

int c[3 + 10], m[3 + 10];

int main () {
    for (int i = 0; i < 3; i++) {
        std::cin >> c[i] >> m[i];
    }
    for (int i = 0; i < 100; i++) {
        int milka = i % 3;
        int milkb = (i + 1) % 3;
        int camt;
        if (m[milka] <= (c[milkb] - m[milkb])) {camt = m[milka];}
        else {camt = c[milkb] - m[milkb];}
        m[milka] -= camt;
        m[milkb] += camt;
    }
    for (int i = 0; i < 3; i++) {
        std::cout << m[i] << std::endl;
    }
    return 0;
}
```
